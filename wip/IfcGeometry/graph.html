<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="graph.css" />
    <title>IFC Relations Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/elkjs@0.8.2/lib/elk.bundled.js"></script>
    <script src="graph-data.js"></script>
</head>
<body>
    <div class="panel">
        <h3>IFC Graph Controls</h3>

        <div class="row">
            <label for="layoutMode"><strong>Layout:</strong></label>
            <select id="layoutMode">
                <option value="force">Force</option>
                <option value="hier-right">Hierarchical →</option>
                <option value="hier-down">Hierarchical ↓</option>
                <option value="hier-left">Hierarchical ←</option>
                <option value="hier-up">Hierarchical ↑</option>
                <option value="circle">Circle</option>
                <option value="grid">Grid</option>
                <option value="radial">Radial (BFS)</option>
                <option value="concentric">Concentric</option>
            </select>
        </div>

        <div class="row">
            <label><input type="checkbox" id="sizeByCount" checked> Size nodes by count</label>
        </div>

        <div class="row buttons">
            <button id="fitBtn" title="Fit all visible nodes into view">Fit</button>
            <button id="freezeBtn" title="Stop/resume simulation">Freeze</button>
            <button id="unpinBtn" title="Unpin all user-pinned nodes">Unpin all</button>
        </div>
    </div>

    <svg></svg>

    <script>


        // ===== Example hard-coded data =====
        // 'nodes' defines per-node properties (color, count).
        // 'relations' maps SOURCE -> one or more { name: TARGET, count: edgeCount }.
        const data = window.data;

        // =======================
        // Build nodes & links
        // =======================
        const nodesMap = new Map();
        if (data.nodes) {
            for (const [id, props] of Object.entries(data.nodes)) nodesMap.set(id, { id, ...(props || {}) });
        }
        function ensureNode(id) { if (!nodesMap.has(id)) nodesMap.set(id, { id }); return nodesMap.get(id); }

        const rawRelations = data.relations ?? {};
        const links = [];
        function addRelation(source, rel) {
            const target = rel.name;
            const cnt = +rel.count || 0;
            ensureNode(source); ensureNode(target);
            links.push({ source, target, label: String(cnt), countNum: cnt });
        }
        for (const [source, val] of Object.entries(rawRelations)) {
            if (Array.isArray(val)) val.forEach(r => addRelation(source, r));
            else if (val && typeof val === "object") addRelation(source, val);
        }
        const nodes = Array.from(nodesMap.values());

        // =======================
        // Scales & configuration
        // =======================
        const STORAGE_KEY = "ifc-graph-state-v1";
        const width = window.innerWidth, height = window.innerHeight;

        const maxNodeCount = d3.max(nodes, d => d.count || 0) || 1;
        const maxEdgeCount = d3.max(links, d => d.countNum || 0) || 1;

        let sizeByCount = true;
        let layoutMode = "force"; // "force" | "hier"
        let frozen = false;

        // =======================
        // SVG & simulation
        // =======================

        // Precompute once
        const counts = nodes.map(n => n.count || 0).sort(d3.ascending);
        const p95 = d3.quantile(counts, 0.95) || 1;

        // Use capped domain and clamp
        const rScale = d3.scaleSqrt()
            .domain([0, p95])
            .range([12, 48])
            .clamp(true);

        function nodeRadius(d) {
            const c = Math.min(d.count || 0, p95);
            return sizeByCount ? rScale(c) : 22;
        }

        const svg = d3.select("svg");
        const container = svg.append("g");

        const zoom = d3.zoom()
            .scaleExtent([0.2, 4])
            .on("zoom", e => container.attr("transform", e.transform));

        svg.call(zoom);

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody().strength(-350))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(d => nodeRadius(d) + 4));

        const linkSel = container.selectAll(".link")
            .data(links)
            .enter()
            .append("line")
            .attr("class", "link");

        const edgeLabelSel = container.selectAll(".edge-label")
            .data(links)
            .enter()
            .append("text")
            .attr("class", "edge-label")
            .attr("dy", -4)
            .text(d => d.label);
                    
        const nodeSel = container.selectAll(".node")
            .data(nodes, d => d.id)
            .enter()
            .append("g")
            .attr("class", "node")
            .on("dblclick", (e, d) => {
                toggleUserPin(d);
                saveState();
            })
            .call(
                d3.drag()
                    .on("start", (event, d) => {
                        if (!event.active && !frozen) simulation.alphaTarget(0.3).restart();
                        if (!isPinned(d)) { d.pinMode = "user"; d.fx = d.x; d.fy = d.y; } // temp fix while dragging
                    })
                    .on("drag", (event, d) => {
                        d.fx = event.x; d.fy = event.y;
                        if (frozen) ticked(); // manually update while frozen
                    })
                    .on("end", (event, d) => {
                        if (!event.active && !frozen) simulation.alphaTarget(0);
                        saveState();
                    })
            );

        const nodeCircle = nodeSel.append("circle")
            .attr("r", d => nodeRadius(d))
            .attr("fill", d => d.color || "steelblue");

        const nodeLabel = nodeSel.append("text")
            .attr("class", "node-label")
            .attr("dy", "0.1em")
            .text(d => d.id);

        const nodeCountText = nodeSel.append("text")
            .attr("class", "node-count")
            .attr("dy", "1.5em")
            .text(d => (d.count == null ? "" : `count: ${d.count}`));

        const pinIcon = nodeSel.append("text")
            .attr("class", "pin-icon")
            .text("📍");

        // Position pin icon relative to node radius
        function positionPinIcons() {
            nodeSel.each(function (d) {
                const r = nodeRadius(d);
                d3.select(this).select(".pin-icon")
                    .attr("x", r - 2)
                    .attr("y", -r + 10)
                    .classed("hidden", !isPinned(d));
            });
        }

        function ticked() {
            linkSel
                .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);

            edgeLabelSel
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2);

            nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
            positionPinIcons();
        }
        simulation.on("tick", ticked);

        // =======================
        // Helpers
        // =======================



        function isPinned(d) { return d.fx != null && d.fy != null; }

        function toggleUserPin(d) {
            if (d.pinMode === "user" && isPinned(d)) {
                d.fx = null; d.fy = null; d.pinMode = null;
            } else {
                d.fx = d.x; d.fy = d.y; d.pinMode = "user";
            }
            positionPinIcons();
        }

        function unpinAll({ includeLayout = true } = {}) {
            let changed = false;
            nodes.forEach(d => {
                if (isPinned(d) && (includeLayout || d.pinMode !== "layout")) {
                    d.fx = null; d.fy = null; d.pinMode = null;
                    changed = true;
                }
            });
            positionPinIcons();
            if (changed) {
                if (!frozen) simulation.alpha(0.15).restart();
                else ticked(); // at least redraw icons while frozen
            }
        }        

        function applySizes() {
            nodeCircle.attr("r", d => nodeRadius(d));
            container.selectAll(".node").each(function (d) {
                // TODO: Update collision radius function implicitly uses nodeRadius
            });
            positionPinIcons();
            simulation.alpha(0.12).restart();
        }

        function idOf(x) { return typeof x === "string" ? x : x.id; }

        function fitToView(pad = 40) {
            // Compute bbox of visible nodes
            const visible = nodes.filter(n => !d3.select(nodeSel.filter(d => d === n).node()).classed("hidden"));
            const arr = visible.length ? visible : nodes;
            const minX = d3.min(arr, d => d.x), maxX = d3.max(arr, d => d.x);
            const minY = d3.min(arr, d => d.y), maxY = d3.max(arr, d => d.y);
            const w = maxX - minX + 2 * pad, h = maxY - minY + 2 * pad;
            const midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
            const svgW = svg.node().clientWidth, svgH = svg.node().clientHeight;

            const k = Math.max(0.2, Math.min(4, 0.9 * Math.min(svgW / w, svgH / h)));
            const tx = svgW / 2 - k * midX;
            const ty = svgH / 2 - k * midY;

            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
        }

        // ---- Graph helpers for layouts ----
        function buildAdjacency() {
            const map = new Map(nodes.map(n => [n.id, new Set()]));
            for (const l of links) {
                const a = idOf(l.source), b = idOf(l.target);
                if (!map.has(a)) map.set(a, new Set());
                if (!map.has(b)) map.set(b, new Set());
                map.get(a).add(b);
                map.get(b).add(a);
            }
            return map;
        }

        function degreeMap() {
            const adj = buildAdjacency();
            const deg = new Map(nodes.map(n => [n.id, 0]));
            for (const [k, set] of adj) deg.set(k, set.size);
            return deg;
        }

        function pickRootByDegree() {
            const deg = degreeMap();
            let best = nodes[0]?.id, bestD = -1;
            for (const n of nodes) {
                const d = deg.get(n.id) || 0;
                if (d > bestD) { best = n.id; bestD = d; }
            }
            return best;
        }

        // Pins node positions as "layout" pins
        function pinAt(n, x, y) {
            n.x = x; n.y = y; n.fx = x; n.fy = y; n.pinMode = "layout";
        }

        // =======================
        // Hierarchical layout (ELK)
        // =======================
        const elk = new ELK();
        async function runHierLayout(direction = "RIGHT") {
            const elkGraph = {
                id: "root",
                layoutOptions: {
                    "elk.algorithm": "layered",
                    "elk.direction": direction,                 // <— now dynamic
                    "elk.spacing.nodeNode": "30",
                    "elk.layered.spacing.nodeNodeBetweenLayers": "60",
                    "elk.spacing.edgeEdge": "20"
                },
                children: nodes.map(n => ({ id: n.id, width: 140, height: 40 })),
                edges: links.map((l, i) => ({
                    id: `e${i}`, sources: [idOf(l.source)], targets: [idOf(l.target)]
                }))
            };

            const result = await elk.layout(elkGraph);
            const posById = new Map(result.children.map(c => [c.id, c]));
            nodes.forEach(n => {
                const c = posById.get(n.id);
                if (c) {
                    const x = c.x + c.width / 2, y = c.y + c.height / 2;
                    pinAt(n, x, y);
                }
            });

            positionPinIcons(); ticked();
            if (!frozen) simulation.alpha(0.001).restart();
        }

        function clearLayoutPins() {
            nodes.forEach(n => {
                if (n.pinMode === "layout") { n.fx = null; n.fy = null; n.pinMode = null; }
            });
            positionPinIcons();
            if (!frozen) simulation.alpha(0.15).restart();
        }


        function runCircleLayout() {
            const cx = svg.node().clientWidth / 2;
            const cy = svg.node().clientHeight / 2;
            const R = Math.max(120, Math.min(cx, cy) - 60);
            const N = nodes.length;
            nodes.forEach((n, i) => {
                const a = (2 * Math.PI * i) / N;
                pinAt(n, cx + R * Math.cos(a), cy + R * Math.sin(a));
            });
            positionPinIcons(); ticked();
            if (!frozen) simulation.alpha(0.03).restart();
        }

        function runGridLayout() {
            const W = svg.node().clientWidth, H = svg.node().clientHeight;
            const N = nodes.length;
            const cols = Math.ceil(Math.sqrt(N * (W / H)));
            const rows = Math.ceil(N / cols);
            const pad = 80;
            const cellW = (W - 2 * pad) / Math.max(1, cols);
            const cellH = (H - 2 * pad) / Math.max(1, rows);
            nodes.forEach((n, i) => {
                const c = i % cols, r = Math.floor(i / cols);
                const x = pad + c * cellW + cellW / 2;
                const y = pad + r * cellH + cellH / 2;
                pinAt(n, x, y);
            });
            positionPinIcons(); ticked();
            if (!frozen) simulation.alpha(0.03).restart();
        }

        function runRadialLayout(rootId = null) {
            const adj = buildAdjacency();
            const root = rootId || pickRootByDegree();

            // BFS layers
            const depth = new Map(nodes.map(n => [n.id, Infinity]));
            const Q = [root];
            depth.set(root, 0);
            for (let qi = 0; qi < Q.length; qi++) {
                const u = Q[qi];
                for (const v of (adj.get(u) || [])) if (depth.get(v) === Infinity) {
                    depth.set(v, depth.get(u) + 1);
                    Q.push(v);
                }
            }
            // Unreached nodes => last layer
            let maxD = 0;
            for (const v of depth.values()) if (isFinite(v) && v > maxD) maxD = v;
            for (const n of nodes) if (depth.get(n.id) === Infinity) depth.set(n.id, maxD + 1);
            maxD = Math.max(maxD, ...nodes.map(n => depth.get(n.id)));

            // Place per layer on concentric circles
            const cx = svg.node().clientWidth / 2;
            const cy = svg.node().clientHeight / 2;
            const ringGap = 140; // distance between layers
            const baseR = 40;

            // Group nodes by depth
            const layers = Array.from({ length: maxD + 1 }, () => []);
            nodes.forEach(n => layers[depth.get(n.id)].push(n));

            layers.forEach((layer, li) => {
                const R = baseR + li * ringGap;
                const k = layer.length;
                if (k === 1) {
                    pinAt(layer[0], cx + R, cy);
                } else {
                    layer.forEach((n, i) => {
                        const a = (2 * Math.PI * i) / k;
                        pinAt(n, cx + R * Math.cos(a), cy + R * Math.sin(a));
                    });
                }
            });

            positionPinIcons(); ticked();
            if (!frozen) simulation.alpha(0.03).restart();
        }

        function runConcentricLayout({
            baseR = 60,        // starting radius for inner ring (px)
            gapPx = 18,        // linear gap along the ring between neighbors (px)
            minRadialGap = 40  // extra radial clearance between rings (px)
        } = {}) {
            const rect = svg.node().getBoundingClientRect();
            const cx = (rect.width || window.innerWidth) / 2;
            const cy = (rect.height || window.innerHeight) / 2;
            const twoPi = 2 * Math.PI;

            // Order nodes (big first spreads them out better). Tweak metric as desired.
            const deg = degreeMap();
            const metric = n => (deg.get(n.id) || 0) + (n.count || 0);
            const ordered = nodes.slice().sort((a, b) => metric(b) - metric(a));

            const rings = [];
            let R = baseR;
            let i = 0;

            // Greedy packing by circumference: put nodes on a ring until their
            // required arc lengths would exceed the ring's circumference.
            while (i < ordered.length) {
                const ring = [];
                let circ = twoPi * R;
                let used = 0;
                let maxR = 0;

                while (i < ordered.length) {
                    const n = ordered[i];
                    const ri = nodeRadius(n);          // pixel radius of this node
                    const need = 2 * ri + gapPx;       // required arc length on circumference (px)

                    // If first node can't fit, grow ring so it does
                    if (ring.length === 0 && need > circ) {
                        R = (need * 1.05) / twoPi;
                        circ = twoPi * R;
                    }

                    // Take it if it fits (or if it's the first)
                    if (ring.length === 0 || used + need <= circ) {
                        ring.push({ n, ri, need });
                        used += need;
                        if (ri > maxR) maxR = ri;
                        i++;
                    } else {
                        break;
                    }
                }

                rings.push({ R, ring, maxR });
                // Grow next ring by this ring’s max diameter + extra gap
                R += (maxR * 2 + minRadialGap);
            }

            // Place nodes on each ring: turn linear arc lengths into angles so the circle is filled.
            rings.forEach(({ R, ring }) => {
                const circ = twoPi * R;
                const totalNeed = ring.reduce((s, x) => s + x.need, 0);
                const scale = circ / totalNeed; // stretch factor so we use full 360°

                let t = 0; // accumulated arc length
                ring.forEach(({ n, need }) => {
                    const L = need * scale;   // actual arc length assigned
                    const a = (t + L / 2) / R; // angle (rad) = arc / radius, centered in its slot
                    const x = cx + R * Math.cos(a);
                    const y = cy + R * Math.sin(a);
                    pinAt(n, x, y);           // sets x,y,fx,fy and pinMode="layout"
                    t += L;
                });
            });

            positionPinIcons();
            ticked();
            if (!frozen) simulation.alpha(0.03).restart();
        }

        // =======================
        // State persistence
        // =======================
        function saveState() {
            const t = d3.zoomTransform(svg.node());
            const nodeState = {};
            nodes.forEach(n => {
                nodeState[n.id] = {
                    x: n.x, y: n.y, fx: n.fx, fy: n.fy, pinMode: n.pinMode || null
                };
            });
            const state = {
                layoutMode, sizeByCount, frozen,
                transform: { k: t.k, x: t.x, y: t.y },
                nodes: nodeState
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function loadState() {
            const s = localStorage.getItem(STORAGE_KEY);
            if (!s) return;
            try {
                const st = JSON.parse(s);
                layoutMode = st.layoutMode || layoutMode;
                sizeByCount = !!st.sizeByCount;
                frozen = !!st.frozen;

                // Restore node positions/pins
                if (st.nodes) {
                    nodes.forEach(n => {
                        const ns = st.nodes[n.id];
                        if (!ns) return;
                        if (typeof ns.x === "number") n.x = ns.x;
                        if (typeof ns.y === "number") n.y = ns.y;
                        n.fx = (ns.fx == null ? null : ns.fx);
                        n.fy = (ns.fy == null ? null : ns.fy);
                        n.pinMode = ns.pinMode || null;
                    });
                    ticked();
                }

                // Restore transform
                if (st.transform) {
                    const { k, x, y } = st.transform;
                    svg.call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(k));
                }
            } catch (e) { console.warn("Failed to load state:", e); }
        }

        // =======================
        // Controls wiring
        // =======================
        const $ = sel => document.querySelector(sel);
        const layoutModeSel = $("#layoutMode");
        const sizeByCountSel = $("#sizeByCount");
        const fitBtn = $("#fitBtn");
        const freezeBtn = $("#freezeBtn");
        const unpinBtn = $("#unpinBtn");


        // Initialize from saved state (before applying controls)
        loadState();

        // Reflect control states in UI
        layoutModeSel.value = layoutMode;
        sizeByCountSel.checked = sizeByCount;
        freezeBtn.textContent = frozen ? "Unfreeze" : "Freeze";

        // Apply initial sizes/filters & layout
        applySizes();
        if (layoutMode === "hier") runHierLayout();

        // Control handlers
        layoutModeSel.addEventListener("change", async () => {
            layoutMode = layoutModeSel.value;

            if (layoutMode === "force") {
                clearLayoutPins();
            } else if (layoutMode.startsWith("hier-")) {
                const dir = layoutMode.split("-")[1].toUpperCase(); // RIGHT/DOWN/LEFT/UP
                await runHierLayout(dir);
            } else if (layoutMode === "circle") {
                runCircleLayout();
            } else if (layoutMode === "grid") {
                runGridLayout();
            } else if (layoutMode === "radial") {
                runRadialLayout(); // or pass a specific rootId
            } else if (layoutMode === "concentric") {
                runConcentricLayout({ rings: 4 });
            }

            saveState();
        });

        sizeByCountSel.addEventListener("change", () => {
            sizeByCount = sizeByCountSel.checked;
            applySizes(); saveState();
        });

        fitBtn.addEventListener("click", () => { fitToView(); });

        freezeBtn.addEventListener("click", () => {
            frozen = !frozen;
            if (frozen) simulation.stop();
            else simulation.restart();
            freezeBtn.textContent = frozen ? "Unfreeze" : "Freeze";
            saveState();
        });

        unpinBtn.addEventListener("click", () => { unpinAll(); saveState(); });

        // Resize handling keeps centering force current
        window.addEventListener("resize", () => {
            const w = svg.node().clientWidth, h = svg.node().clientHeight;
            simulation.force("center", d3.forceCenter(w / 2, h / 2));
            if (!frozen) simulation.alpha(0.1).restart();
        });

        // Save state on unload
        window.addEventListener("beforeunload", saveState);
    </script>
</body>
</html>