using Autodesk.Revit.DB;
using System.Collections.Generic;
using System.Linq;
using Material = Ara3D.Models.Material;

namespace Ara3D.Bowerbird.RevitSamples;

/// <summary>
/// A mesh with an index, a symbol and a transform  
/// </summary>
public sealed record GeometryPart
(
    Transform Transform,
    int MeshIndex,
    Material? Material
);

public sealed record Geometry
(
    DocumentKey SourceDocumentKey,
    long ElementIdValue,
    Material? DefaultMaterial,
    IReadOnlyList<GeometryPart> Parts
);

/// <summary>
/// Used for uniquely identify a symbol ID by combining it with a document key 
/// </summary>
public readonly record struct GeometrySymbolKey
(
    DocumentKey DocumentKey,
    string SymbolId
);

public class MeshGatherer
{
    public RevitBimDataBuilder RevitBimDataBuilder;
    public Document CurrentDocument { get; private set; }
    public DocumentKey CurrentDocumentKey { get; private set; }
    public HashSet<DocumentKey> ProcessedDocuments { get; } = [];
    public List<Mesh> MeshList { get; } = [];
    public List<Geometry> Geometries { get; } = [];

    public MeshGatherer(RevitBimDataBuilder builder)
    {
        RevitBimDataBuilder = builder;
    }

    private readonly Dictionary<
        GeometrySymbolKey,
        IReadOnlyList<GeometryPart>> _symbolCache = new();

    public static DocumentKey GetDocumentKey(Document d)
        => RevitBimDataBuilder.GetDocumentKey(d);

    public void CollectMeshes(Document doc, Options options, bool recurseLinks, Transform parent)
    {
        var newDocumentKey = GetDocumentKey(doc);
        if (ProcessedDocuments.Contains(newDocumentKey))
            return;

        var previousDocumentKey = CurrentDocumentKey;
        var previousDocument = CurrentDocument;
        CurrentDocument = doc;
        CurrentDocumentKey = newDocumentKey;
        ProcessedDocuments.Add(CurrentDocumentKey);

        try
        {
            options ??= DefaultGeometryOptions();

            var elems = new FilteredElementCollector(doc)
                .WhereElementIsNotElementType()
                .ToElements();

            foreach (var e in elems)
            {
                if (e?.Id == null) continue;
                Geometries.Add(ComputeGeometry(e, parent, options));
            }

            if (recurseLinks)
            {
                foreach (var rli in new FilteredElementCollector(doc)
                             .OfClass(typeof(RevitLinkInstance))
                             .Cast<RevitLinkInstance>())
                {
                    var linkDoc = rli.GetLinkDocument();
                    if (linkDoc is null)
                        continue;

                    var linkTransform = rli.GetTransform();
                    CollectMeshes(linkDoc, options, false, parent.Multiply(linkTransform));
                }
            }
        }
        finally
        {
            CurrentDocument = previousDocument;
            CurrentDocumentKey = previousDocumentKey;
        }
    }

    public IEnumerable<GeometryPart> GetOrComputeCachedGeometryParts(GeometryInstance gi, Options options)
    {
        using var symbolId = gi.GetSymbolGeometryId();

        if (symbolId == null)
        {
            // When things have been cut or modified, the symbolId will return null
            // and the symbol geometry is not applicable so We use GetInstanceGeometry()
            // Geometry is in the coordinate system of the model.
            // https://help.autodesk.com/view/RVT/2024/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Geometry_GeometryObject_Class_GeometryInstances_html
            // The GeometryInstance also stored a transformation from the symbol coordinate space to the instance coordinates. This transform is accessible as the Transform property. It is also the transformation used when extracting a the copy of the geometry via GetInstanceGeometry().
            // This means: we just return the InstanceGeometry
            return ComputeGeometryParts(gi.GetInstanceGeometry(), Transform.Identity, options);
        }

        var stringId = symbolId.AsUniqueIdentifier();
        var key = new GeometrySymbolKey(GetDocumentKey(gi.GetDocument()), stringId);

        // Check if we have to fill out the cache for this string id 
        if (!_symbolCache.ContainsKey(key))
        {
            // Retrieve the geometry in local space of the symbol
            var geometryElement = gi.GetSymbolGeometry();

            // Get all geometric parts 
            var parts = ComputeGeometryParts(geometryElement, Transform.Identity, options);
            _symbolCache.Add(key, parts);
        }

        // Return the cached symbols, transformed appropriately 
        return _symbolCache[key].Select(part => ApplyInstanceTransform(part, gi.Transform));
    }

    public static GeometryPart ApplyInstanceTransform(GeometryPart part, Transform instanceTransform)
        => part with { Transform = instanceTransform.Multiply(part.Transform) };

    public Geometry ComputeGeometry(Element e, Transform transform, Options options)
    {
        var docKey = GetDocumentKey(e.Document);
        var material = ResolveFallbackMaterial(e);
        var parts = ComputeGeometryParts(e, transform, options);
        if (parts.Count == 0) return null;
        return new Geometry(docKey, e.Id.Value, material, parts);
    }

    public IReadOnlyList<GeometryPart> ComputeGeometryParts(Element e, Transform transform, Options options)
    {
        return ComputeGeometryParts(e.get_Geometry(options), transform, options);
    }

    public void AccumulateGeometryParts(GeometryObject go, Transform transform, List<GeometryPart> list,
        Options options)
    {
        switch (go)
        {
            case Solid s when s.Faces.Size > 0:
                list.AddRange(ToGeometryParts(s, transform));
                break;

            case Mesh m when m.Vertices.Count > 0:
                list.Add(new GeometryPart(transform, AddMesh(m), GetMaterial(m)));
                break;

            case GeometryInstance gi:
                var parts = GetOrComputeCachedGeometryParts(gi, options);
                list.AddRange(parts.Select(p => p with { Transform = transform.Multiply(p.Transform) }));
                break;

            case Curve c:
                // ignore non-surface geometry
                break;

            case PolyLine pl:
                // ignore wireframe
                break;

            case Point p:
                // ignore points
                break;

            case Face f:
                // Very rare to get a stray Face here, but handle it
                var gp = ToGeometryPart(f, transform);
                if (gp != null)
                    list.Add(gp);
                break;

            default:
                // Other types (e.g., Line, Arc, etc.) are not tessellated here
                break;
        }
    }

    /// <summary>
    /// A geometry element contains a collection of geometric primitives. 
    /// </summary>
    public IReadOnlyList<GeometryPart> ComputeGeometryParts(GeometryElement ge, Transform transform, Options options)
    {
        var list = new List<GeometryPart>();
        if (ge == null)
            return list;
        foreach (var go in ge)
            AccumulateGeometryParts(go, transform, list, options);
        return list;
    }

    public int AddMesh(Mesh mesh)
    {
        MeshList.Add(mesh);
        return MeshList.Count - 1;
    }

    public GeometryPart ToGeometryPart(Face f, Transform tf)
    {
        if (f == null) return null;
        var mesh = f.Triangulate();
        if (mesh == null) return null;
        if (mesh.NumTriangles == 0) return null;
        return new(tf, AddMesh(mesh), GetMaterial(f));
    }

    public IEnumerable<GeometryPart> ToGeometryParts(Solid s, Transform tf)
        => s.Faces.OfType<Face>().Select(f => ToGeometryPart(f, tf)).Where(gp => gp != null);

    public static Options DefaultGeometryOptions()
        => new()
        {
            DetailLevel = ViewDetailLevel.Medium,
            ComputeReferences = false,
            IncludeNonVisibleObjects = false,
        };

    //==
    // Material code

    public static Material? ToMaterial(PbrMaterialInfo pbr)
        => pbr == null
            ? null
            : new Material(pbr.BaseColor ?? pbr.ShadingColor, (float)(pbr.Metallic ?? 0),
                (float)(pbr.Roughness ?? 0));

    public static Material? ToMaterial(Document doc, ElementId? materialId)
    {
        if (doc == null)
            return null;
        if (materialId == null)
            return null;
        if (materialId == ElementId.InvalidElementId)
            return null;
        var pbrMatInfo = doc.GetPbrInfo(materialId.Value);
        return ToMaterial(pbrMatInfo);
    }

    public Material? GetMaterial(Face f)
        => ToMaterial(CurrentDocument, f?.MaterialElementId);

    public Material? GetMaterial(Mesh m)
        => ToMaterial(CurrentDocument, m?.MaterialElementId);

    public static Material? ResolveFallbackMaterial(Element e)
        => e == null ? null : ToMaterial(e.Document, ResolveFallbackMaterialId(e));

    public static ElementId ResolveFallbackMaterialId(Element e)
    {
        // Try element's own material parameter first 
        var pMat = e.get_Parameter(BuiltInParameter.MATERIAL_ID_PARAM);
        if (pMat is { StorageType: StorageType.ElementId })
        {
            var id = pMat.AsElementId();
            if (id != ElementId.InvalidElementId)
                return id;
        }

        // QUESTION: is there anything else that is appropriate as a fallback?

        // Use the category material as a fallback 
        var mat = e.Category?.Material;
        return mat != null
            ? mat.Id
            : ElementId.InvalidElementId;
    }

    //==

    /// <summary>
    /// Returns (and caches) the template meshes for a symbol geometry.
    /// Each template stores:
    /// - MeshIndex into the global meshes list
    /// - ToSymbol: transform from mesh-local coordinates to the symbol root coordinates
    /// 
    /// This runs at most once per unique SymbolGeometryId.
    /// </summary>
    private IReadOnlyList<GeometryPart> GetOrBuildSymbolTemplates(GeometryInstance gi)
    {
        if (gi == null) return [];

        // SymbolGeometryId is a value object; Revit API doesn't document
        // it as nullable. We still guard against weird cases defensively.
        var symbolId = gi.GetSymbolGeometryId();
        var symbolIdStr = symbolId?.AsUniqueIdentifier();

        if (string.IsNullOrEmpty(symbolIdStr))
        {
            // Fallback: if for any reason we can't get a stable id,
            // treat this instance as non-dedupable and just use
            // symbol geometry directly (no caching).
            var templatesNoCache = new List<GeometryPart>();
            var symGeom = gi.GetSymbolGeometry();
            if (symGeom != null)
            {
                BuildSymbolTemplates(
                    symGeom,
                    Transform.Identity,
                    templatesNoCache);
            }

            return templatesNoCache;
        }

        var key = new GeometrySymbolKey(CurrentDocumentKey, symbolIdStr);
        if (_symbolCache.TryGetValue(key, out var existing))
            return existing;

        var templates = new List<GeometryPart>();
        var symbolGeom = gi.GetSymbolGeometry();
        if (symbolGeom != null)
        {
            // Build templates with transforms expressed in symbol-root coordinates.
            BuildSymbolTemplates(
                symbolGeom,
                Transform.Identity, // toSymbol: geometry-local -> symbol-root
                templates);
        }

        _symbolCache[key] = templates;
        return templates;
    }

    /// <summary>
    /// Recursively traverses symbol geometry and fills 'templates' with TemplateMesh entries.
    ///  - 'toSymbol' is the accumulated transform from the current geometry context
    ///   to the symbol's root coordinates (NOT to model coordinates).
    /// </summary>
    public void BuildSymbolTemplates(
        GeometryElement geom,
        Transform toSymbol,
        List<GeometryPart> templates)
    {
        foreach (var obj in geom)
        {
            switch (obj)
            {
                case Solid solid when solid.Faces.Size > 0:
                    AddSymbolSolidMeshesToTemplates(
                        solid,
                        toSymbol,
                        templates);
                    break;

                case Mesh mesh:
                    AddSymbolMeshToTemplates(
                        mesh,
                        toSymbol,
                        templates);
                    break;

                case GeometryInstance nestedGi:
                    {
                        var nestedGeom = nestedGi.GetSymbolGeometry();
                        if (nestedGeom == null)
                            break;

                        // nestedToSymbol: geometry-local -> symbol-root
                        var nestedToSymbol = toSymbol.Multiply(nestedGi.Transform);
                        BuildSymbolTemplates(
                            nestedGeom,
                            nestedToSymbol,
                            templates);
                        break;
                    }

                case GeometryElement subGeom:
                    BuildSymbolTemplates(
                        subGeom,
                        toSymbol,
                        templates);
                    break;

                default:
                    // Ignore curves, points, etc.
                    break;
            }
        }
    }

    private void AddSymbolSolidMeshesToTemplates(
        Solid solid,
        Transform toSymbol,
        List<GeometryPart> templates)
    {
        foreach (Face face in solid.Faces)
        {
            if (face == null) 
                continue;
            var faceMesh = face.Triangulate();
            if (faceMesh == null || faceMesh.NumTriangles == 0)
                continue;
            var meshIndex = AddMesh(faceMesh);
            templates.Add(new GeometryPart(toSymbol, meshIndex, GetMaterial(face)));
        }
    }

    private void AddSymbolMeshToTemplates(
        Mesh mesh,
        Transform toSymbol,
        List<GeometryPart> templates)
    {
        if (mesh == null || mesh.NumTriangles == 0)
            return;
        var index = AddMesh(mesh);
        templates.Add(new GeometryPart(toSymbol, index, GetMaterial(mesh)));
    }
}

